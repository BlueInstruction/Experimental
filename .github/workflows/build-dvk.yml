name: Build DXVK (Steam Deck)

on:
  schedule:
    - cron: "0 21 * * *"
  workflow_dispatch:
    inputs:
      FORCE_MODE:
        type: boolean
        default: false
      VERSION:
        description: "Version"
        required: false
        default: ""
      BUILD_TYPE:
        type: choice
        default: "release"
        options: ["release", "debug"]
  workflow_call:
    inputs:
      VERSION:
        type: string
        required: false
        default: ""
    outputs:
      version:
        value: ${{ jobs.build.outputs.version }}
      artifact_name:
        value: ${{ jobs.build.outputs.artifact_name }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: write

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ env.VER }}
      artifact_name: ${{ env.PKG }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            /var/cache/apt
          key: ${{ runner.os }}-dxvk-deps-${{ hashFiles('**/workflow.yml') }}
          restore-keys: |
            ${{ runner.os }}-dxvk-deps-

      - name: Setup Dependencies
        run: |
          sudo dpkg --add-architecture i386
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            git meson ninja-build curl jq python3 \
            glslang-tools spirv-tools zstd \
            gcc-mingw-w64-x86-64 gcc-mingw-w64-i686 \
            g++-mingw-w64-x86-64 g++-mingw-w64-i686 \
            mingw-w64 mingw-w64-tools binutils-mingw-w64 \
            wine64 wine32
          sudo update-alternatives --set x86_64-w64-mingw32-gcc /usr/bin/x86_64-w64-mingw32-gcc-posix 2>/dev/null || true
          sudo update-alternatives --set x86_64-w64-mingw32-g++ /usr/bin/x86_64-w64-mingw32-g++-posix 2>/dev/null || true
          sudo update-alternatives --set i686-w64-mingw32-gcc /usr/bin/i686-w64-mingw32-gcc-posix 2>/dev/null || true
          sudo update-alternatives --set i686-w64-mingw32-g++ /usr/bin/i686-w64-mingw32-g++-posix 2>/dev/null || true

      - name: Fetch Version
        run: |
          if [[ -n "${{ inputs.VERSION }}" ]]; then
            VER="${{ inputs.VERSION }}"
            [[ "$VER" =~ ^v ]] || VER="v$VER"
          else
            VER=$(curl -sL https://api.github.com/repos/doitsujin/dxvk/releases/latest | jq -r '.tag_name // empty')
            [[ -z "$VER" ]] && VER=$(curl -sL https://api.github.com/repos/doitsujin/dxvk/releases | jq -r '.[0].tag_name')
          fi
          echo "TAG=$VER" >> $GITHUB_ENV
          echo "VER=${VER#v}" >> $GITHUB_ENV
          echo "BUILD_DATE=$(date +%Y%m%d)" >> $GITHUB_ENV

      - name: Check Release
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          RELEASE_TAG="dxvk-steamdeck-${{ env.VER }}"
          EXISTS=$(gh release view "$RELEASE_TAG" --repo ${{ github.repository }} 2>/dev/null && echo "true" || echo "false")
          [[ "${{ inputs.FORCE_MODE }}" == "true" ]] && EXISTS="false"
          echo "SKIP=$EXISTS" >> $GITHUB_OUTPUT
          echo "RELEASE_TAG=$RELEASE_TAG" >> $GITHUB_ENV

      - name: Clone Source
        if: steps.check.outputs.SKIP == 'false'
        run: |
          git clone --recurse-submodules --recursive --branch ${{ env.TAG }} --depth 1 \
            https://github.com/doitsujin/dxvk.git src
          cd src && chmod +x ./package-release.sh
          COMMIT=$(git rev-parse --short HEAD)
          echo "COMMIT=$COMMIT" >> $GITHUB_ENV
          echo "BUILD_ID=${{ env.VER }}-${COMMIT:0:7}" >> $GITHUB_ENV

      - name: Apply Patches
        if: steps.check.outputs.SKIP == 'false'
        run: |
          cd src
          cat > patch.py << 'PYSCRIPT'
          import re, os, sys, json, glob
          from datetime import datetime

          applied = 0
          errors = []

          GPU_VENDOR_ID = "0x1002"
          GPU_DEVICE_ID = "0x163F"
          GPU_NAME = "AMD Custom GPU 0405"
          GPU_VRAM_MB = 1024
          GPU_SHARED_MB = 16384

          def patch_file(path, patches):
              global applied, errors
              if not os.path.exists(path):
                  errors.append(f"File not found: {path}")
                  return
              try:
                  with open(path, "r", encoding='utf-8', errors='ignore') as f:
                      c = f.read()
              except Exception as e:
                  errors.append(f"Read error {path}: {e}")
                  return
              orig = c
              for p, r in patches:
                  m = len(re.findall(p, c))
                  if m > 0:
                      c = re.sub(p, r, c)
                      applied += m
              if c != orig:
                  try:
                      with open(path, "w", encoding='utf-8') as f:
                          f.write(c)
                  except Exception as e:
                      errors.append(f"Write error {path}: {e}")

          gpu_spoof = [
              (r'(VkVendorId\s*=\s*)[^;]+;', rf'\g<1>{GPU_VENDOR_ID};'),
              (r'(vendorId\s*=\s*)[^;]+;', rf'\g<1>{GPU_VENDOR_ID};'),
              (r'(adapter_id\.vendor_id\s*=\s*)[^;]+;', rf'\g<1>{GPU_VENDOR_ID};'),
              (r'(VendorId\s*=\s*)[^;]+;', rf'\g<1>{GPU_VENDOR_ID};'),
              (r'(VkDeviceId\s*=\s*)[^;]+;', rf'\g<1>{GPU_DEVICE_ID};'),
              (r'(deviceId\s*=\s*)[^;]+;', rf'\g<1>{GPU_DEVICE_ID};'),
              (r'(adapter_id\.device_id\s*=\s*)[^;]+;', rf'\g<1>{GPU_DEVICE_ID};'),
              (r'(DeviceId\s*=\s*)[^;]+;', rf'\g<1>{GPU_DEVICE_ID};'),
              (r'(DedicatedVideoMemory\s*=\s*)[^;]+;', rf'\g<1>{GPU_VRAM_MB}ULL * 1024 * 1024;'),
              (r'(SharedSystemMemory\s*=\s*)[^;]+;', rf'\g<1>{GPU_SHARED_MB}ULL * 1024 * 1024;'),
          ]

          memory_patches = [
              (r'(DxvkMemoryAllocator::allocateChunk\([^{]*\{)',
               r'\1\n'
               r'    // Steam Deck optimization: Limit chunk size for APU shared memory\n'
               r'    const auto& props = m_device->adapter()->deviceProperties();\n'
               r'    if (props.core.properties.vendorID == 0x1002 &&\n'
               r'        props.core.properties.deviceID == 0x163F &&\n'
               r'        size > (128 << 20)) {\n'
               r'      size = 128 << 20;\n'
               r'      Logger::info("DXVK: Using 128MB chunk size for Steam Deck APU");\n'
               r'    }'),
          ]

          pipeline_patches = [
              (r'(uint32_t\s+numCompilers\s*=\s*\(cpuCount\s*-\s*1\)\s*/\s*2;)',
               r'\1\n'
               r'    // Steam Deck: Zen 2 4C/8T - limit to 3 compiler threads\n'
               r'    const auto& props = m_device->adapter()->deviceProperties();\n'
               r'    if (props.core.properties.vendorID == 0x1002 &&\n'
               r'        props.core.properties.deviceID == 0x163F &&\n'
               r'        numCompilers > 3) {\n'
               r'      numCompilers = 3;\n'
               r'      Logger::info("DXVK: Limiting compiler threads to 3 for Steam Deck");\n'
               r'    }'),
          ]

          for root, dirs, files in os.walk("."):
              for f in files:
                  if not f.endswith((".cpp", ".h", ".c")):
                      continue
                  path = os.path.join(root, f)
                  if "dxvk_memory" in f:
                      patch_file(path, memory_patches)
                  if "dxvk_pipemanager" in f:
                      patch_file(path, pipeline_patches)
                  if any(k in f for k in ["adapter", "device", "d3d9", "d3d11", "dxgi"]):
                      patch_file(path, gpu_spoof)

          report = {
              "v": "2.1.0",
              "t": datetime.utcnow().isoformat(),
              "target": "dxvk",
              "profile": "steam-deck",
              "gpu": {
                  "vid": GPU_VENDOR_ID,
                  "did": GPU_DEVICE_ID,
                  "name": GPU_NAME,
                  "vram_mb": GPU_VRAM_MB,
                  "shared_mb": GPU_SHARED_MB
              },
              "applied": applied,
              "errors": len(errors)
          }

          with open("../patch-report.json", "w") as f:
              json.dump(report, f, indent=2)

          print(f"Profile: Steam Deck ({GPU_NAME})")
          print(f"GPU: {GPU_VENDOR_ID}:{GPU_DEVICE_ID}")
          print(f"Applied {applied} patches")
          if errors:
              print(f"Warnings: {len(errors)}")
              for e in errors[:10]:
                  print(f"  - {e}")
          PYSCRIPT
          python3 patch.py

      - name: Build
        if: steps.check.outputs.SKIP == 'false'
        run: |
          cd src
          BUILD_FLAGS="-O3 -DNDEBUG -march=znver2 -mtune=znver2"
          [[ "${{ inputs.BUILD_TYPE }}" == "debug" ]] && BUILD_FLAGS="-O0 -g -DDEBUG"
          export CFLAGS="$BUILD_FLAGS"
          export CXXFLAGS="$BUILD_FLAGS"
          export LDFLAGS="-s"
          bash ./package-release.sh ${{ env.TAG }} ../out --no-package 2>&1 | tee build.log
          if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
            echo "Build failed"
            tail -n 100 build.log
            exit 1
          fi

      - name: Verify Build
        if: steps.check.outputs.SKIP == 'false'
        run: |
          SRC=$(find out -maxdepth 1 -type d -name "dxvk-*" | head -1)
          [[ -z "$SRC" ]] && { echo "Build output not found"; exit 1; }
          for a in x64 x86; do
            for d in d3d9.dll d3d10core.dll d3d11.dll dxgi.dll; do
              DLL="$SRC/$a/$d"
              if [[ ! -f "$DLL" ]]; then
                echo "Missing: $DLL"
                exit 1
              fi
              SIZE=$(stat -c%s "$DLL" 2>/dev/null || stat -f%z "$DLL")
              echo "$DLL: ${SIZE} bytes"
            done
          done
          echo "SRC_PATH=$SRC" >> $GITHUB_ENV

      - name: Generate Checksums
        if: steps.check.outputs.SKIP == 'false'
        run: |
          cd "${{ env.SRC_PATH }}"
          find . -name "*.dll" -type f -exec sha256sum {} \; > ../../checksums.txt
          cd ../..
          cat checksums.txt

      - name: Create Package
        if: steps.check.outputs.SKIP == 'false'
        run: |
          mkdir -p pkg/system32 pkg/syswow64
          cp "${{ env.SRC_PATH }}/x64/"*.dll pkg/system32/
          cp "${{ env.SRC_PATH }}/x86/"*.dll pkg/syswow64/
          cp checksums.txt pkg/
          [[ -f patch-report.json ]] && cp patch-report.json pkg/
          cat > pkg/profile.json << JSONEOF
          {
            "type": "DXVK",
            "versionName": "${{ env.VER }}-${{ env.COMMIT }}-steamdeck",
            "versionCode": ${{ env.BUILD_DATE }},
            "buildId": "${{ env.BUILD_ID }}",
            "description": "DXVK ${{ env.VER }} - Steam Deck (AMD Van Gogh)",
            "gpu": {
              "vendor": "AMD",
              "vendorId": "0x1002",
              "device": "AMD Custom GPU 0405 (Van Gogh)",
              "deviceId": "0x163F"
            },
            "files": [
              {"source": "system32/d3d9.dll", "target": "\${system32}/d3d9.dll"},
              {"source": "system32/d3d10core.dll", "target": "\${system32}/d3d10core.dll"},
              {"source": "system32/d3d11.dll", "target": "\${system32}/d3d11.dll"},
              {"source": "system32/dxgi.dll", "target": "\${system32}/dxgi.dll"},
              {"source": "syswow64/d3d9.dll", "target": "\${syswow64}/d3d9.dll"},
              {"source": "syswow64/d3d10core.dll", "target": "\${syswow64}/d3d10core.dll"},
              {"source": "syswow64/d3d11.dll", "target": "\${syswow64}/d3d11.dll"},
              {"source": "syswow64/dxgi.dll", "target": "\${syswow64}/dxgi.dll"}
            ]
          }
          JSONEOF
          PKG="dxvk-${{ env.BUILD_ID }}-steamdeck"
          cd pkg && tar --zstd -cf "../${PKG}.wcp" . && cd ..
          echo "PKG=$PKG" >> $GITHUB_ENV
          echo "PKG_SIZE=$(du -h ${PKG}.wcp | cut -f1)" >> $GITHUB_ENV

      - name: Upload Artifact
        if: steps.check.outputs.SKIP == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PKG }}
          path: |
            ${{ env.PKG }}.wcp
            checksums.txt
            patch-report.json
          retention-days: 30
          compression-level: 9

      - name: Cleanup
        if: always()
        run: |
          rm -rf src out pkg
          echo "Cleanup completed"
